using System;
using UnityEngine;

public class AeroplaneController : MonoBehaviour {
    private float maxEnginePower = 40f;        // The maximum output of the engine.
    private float liftPower = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
    private float airBrake = 3f;        // How much the air brakes effect the drag.
    private float throttleIncreaseFactor = 0.3f;  // The speed with which the throttle changes.
    private float dragIncreaseFactor = 0.001f; // how much drag should increase with speed.

    public float throttle;                    // The amount of throttle being used.
    public bool airBrakes;                     // Whether or not the air brakes are being applied.
    public float moveSpeed;             // How fast the aeroplane is traveling in it's forward direction.
    public float enginePower;                // How much power the engine is being given.
    public float roll;
    public float pitch;
    public float rollInput;
    public float pitchInput;
    public float yawInput;
    public float throttleInput;

    private float initialDrag;         // The drag when the scene starts.
    private float initialAngularDrag;  // The angular drag when the scene starts.
    private float aeroFactor;
    private Rigidbody _rigidbody;

    private bool isCrashed;

    private void Start() {
        _rigidbody = GetComponent<Rigidbody>();
        // Store original drag settings, these are modified during flight.
        initialDrag = _rigidbody.drag;
        initialAngularDrag = _rigidbody.angularDrag;
    }

    private void FixedUpdate() {
        // Read input for the pitch, yaw, roll and throttle of the aeroplane.
        this.rollInput = Input.GetAxis("Mouse X");
        this.pitchInput = Input.GetAxis("Mouse Y");
        this.yawInput = Input.GetAxis("Horizontal");
        this.throttleInput = Input.GetAxis("Vertical");

        Move();
    }

    public void Move() {
        // transfer input parameters into properties.s

        if (!isCrashed) {

            ClampInputs();
            CalculateRollAndPitchAngles();
            CalculateForwardSpeed();
            ControlThrottle();
            CalculateDrag();
            CaluclateAerodynamicEffect();
            CalculateLinearForces();
            CalculateTorque();
        }
    }


    private void ClampInputs() {
        // clamp the inputs to -1 to 1 range
        rollInput = Mathf.Clamp(rollInput, -1, 1);
        pitchInput = Mathf.Clamp(pitchInput, -1, 1);
        yawInput = Mathf.Clamp(yawInput, -1, 1);
        throttleInput = Mathf.Clamp(throttleInput, -1, 1);
    }


    private void CalculateRollAndPitchAngles() {
        // Calculate roll & pitch angles
        // Calculate the flat forward direction (with no y component).
        var flatForward = transform.forward;
        flatForward.y = 0;
        // If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
        if (flatForward.sqrMagnitude > 0) {
            flatForward.Normalize();
            // calculate current pitch angle
            var localFlatForward = transform.InverseTransformDirection(flatForward);
            pitch = Mathf.Atan2(localFlatForward.y, localFlatForward.z);
            // calculate current roll angle
            var flatRight = Vector3.Cross(Vector3.up, flatForward);
            var localFlatRight = transform.InverseTransformDirection(flatRight);
            roll = Mathf.Atan2(localFlatRight.y, localFlatRight.x);
        }
    }


    private void CalculateForwardSpeed() {
        // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
        var localVelocity = transform.InverseTransformDirection(_rigidbody.velocity);
        moveSpeed = Mathf.Max(0, localVelocity.z);
    }


    private void ControlThrottle() {


        // Adjust throttle based on throttle input (or immobilized state)
        throttle = Mathf.Clamp01(throttle + throttleInput * Time.deltaTime * throttleIncreaseFactor);

        // current engine power is just:
        enginePower = throttle * maxEnginePower;
    }


    private void CalculateDrag() {
        // increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
        float extraDrag = _rigidbody.velocity.magnitude * dragIncreaseFactor;
        // Air brakes work by directly modifying drag. This part is actually pretty realistic!
        _rigidbody.drag = (airBrakes ? (initialDrag + extraDrag) * airBrake : initialDrag + extraDrag);
        // Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
        _rigidbody.angularDrag = initialAngularDrag * moveSpeed;
    }


    private void CaluclateAerodynamicEffect() {
        // "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
        // will naturally try to align itself in the direction that it's facing when moving at speed.
        // Without this, the plane would behave a bit like the asteroids spaceship!
        if (_rigidbody.velocity.magnitude > 0) {
            // compare the direction we're pointing with the direction we're moving:
            aeroFactor = Vector3.Dot(transform.forward, _rigidbody.velocity.normalized);
            // multipled by itself results in a desirable rolloff curve of the effect
            aeroFactor *= aeroFactor;
            // Finally we calculate a new velocity by bending the current velocity direction towards
            // the the direction the plane is facing, by an amount based on this aeroFactor
            var newVelocity = Vector3.Lerp(_rigidbody.velocity, transform.forward * moveSpeed,
                                           aeroFactor * moveSpeed * Time.deltaTime);
            _rigidbody.velocity = newVelocity;

            // also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
            // pointing downwards in a stall
            _rigidbody.rotation = Quaternion.Slerp(_rigidbody.rotation,
                                                  Quaternion.LookRotation(_rigidbody.velocity, transform.up),
                                                  Time.deltaTime);
        }
    }


    private void CalculateLinearForces() {
        // Now calculate forces acting on the aeroplane:
        // we accumulate forces into this variable:
        var forces = Vector3.zero;
        // Add the engine power in the forward direction
        forces += enginePower * transform.forward;
        // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
        var liftDirection = Vector3.Cross(_rigidbody.velocity, transform.right).normalized;
        // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
        // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
        // a simple way of doing it automatically:
        //ZERO LIFT
        // Calculate and add the lift power
        var liftPower = moveSpeed * moveSpeed * this.liftPower * aeroFactor;
        forces += liftPower * liftDirection;
        // Apply the calculated forces to the the Rigidbody
        _rigidbody.AddForce(forces);
    }


    private void CalculateTorque() {
        // We accumulate torque forces into this variable:
        var torque = Vector3.zero;
        // Add torque for the pitch based on the pitch input.
        torque += pitchInput * transform.right;
        // Add torque for the yaw based on the yaw input.
        torque += yawInput * transform.up;
        // Add torque for the roll based on the roll input.
        torque += -rollInput * transform.forward;
        // Add torque for banked turning.
        // The total torque is multiplied by the forward speed, so the controls have more effect at high speed,
        // and little effect at low speed, or when not moving in the direction of the nose of the plane
        // (i.e. falling while stalled)
        _rigidbody.AddTorque(torque * moveSpeed * aeroFactor);
    }

    void OnCollisionEnter() {
        Debug.Log("Crashed");
        isCrashed = true;
    }
}
